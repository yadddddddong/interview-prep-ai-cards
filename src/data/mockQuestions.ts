
// Mock questions for the demo version of the app
// In a real implementation, these would be generated based on the user's JD and resume

export const technicalQuestions = [
  {
    text: "请描述你在React项目中如何管理状态？",
    difficulty: "easy",
    modelAnswer: "在React项目中，我通常使用多种状态管理方法，根据项目复杂度选择合适的方案。对于简单组件，我使用useState和useReducer hooks管理局部状态。对于组件间需要共享的状态，我会使用React Context API。当应用规模较大时，我会引入Redux或Zustand等状态管理库，它们提供了可预测的状态容器、统一的状态更新逻辑和强大的中间件生态系统。在最近的项目中，我还探索了React Query和SWR等工具来管理服务器状态，它们提供了缓存、重新验证和乐观UI更新等功能。"
  },
  {
    text: "解释你如何实现一个高性能的前端应用？具体谈谈你采取的优化措施。",
    difficulty: "medium",
    modelAnswer: "要实现高性能的前端应用，我通常采取多方面的优化措施：1）代码层面：实现代码分割和懒加载，减少主包体积；使用memo、useMemo和useCallback避免不必要的重渲染；优化列表渲染，实现虚拟滚动处理大量数据。2）资源优化：对图片进行压缩并使用WebP等现代格式；实现关键CSS内联，非关键CSS的异步加载；使用Tree Shaking移除未使用的代码。3）网络优化：配置合理的缓存策略；实现资源的预加载和预连接；使用CDN分发静态资源；启用HTTP/2或HTTP/3提高并行加载效率。4）构建优化：使用webpack或vite等工具优化构建过程；启用gzip/brotli压缩；分析并减少第三方依赖。5）监控与分析：使用Lighthouse、WebPageTest等工具分析性能指标；实现真实用户监控(RUM)收集性能数据；建立性能预算并持续追踪。在我最近的项目中，通过这些优化措施，我们将页面加载时间减少了40%，First Contentful Paint提升了60%。"
  },
  {
    text: "在处理大规模前端项目时，你如何确保代码质量和可维护性？",
    difficulty: "hard",
    modelAnswer: "在大规模前端项目中，我遵循以下策略确保代码质量和可维护性：1）架构层面：实施微前端架构，将应用拆分为更易管理的模块；采用DDD（领域驱动设计）原则组织业务逻辑；实现清晰的分层架构，分离UI、业务逻辑和数据访问。2）代码规范：使用ESLint、Prettier和StyleLint强制代码风格一致性；采用Husky和lint-staged在提交前自动检查代码；建立团队一致的命名约定和文件组织结构。3）测试策略：实现全面的测试金字塔，包括单元测试、集成测试和E2E测试；使用Jest、Testing Library和Cypress等工具；追踪测试覆盖率并设置最低阈值。4）文档与注释：为核心组件和关键业务逻辑编写详细文档；使用JSDoc和TypeDoc生成API文档；确保复杂算法和业务规则有充分注释。5）持续优化：定期进行代码审查；使用SonarQube等工具检测代码气味；定期重构技术债务；建立性能基准并避免回归。6）知识分享：组织定期的技术分享会；建立内部知识库；实施结对编程，特别是处理核心模块时。通过这些措施，我们在上一个拥有50多名开发者的大型项目中，即使在快速迭代的同时，也成功维持了高水平的代码质量和可维护性。"
  },
  {
    text: "谈谈你对前端工程化的理解及实践经验。",
    difficulty: "medium",
    modelAnswer: "前端工程化是通过规范化、自动化和工具化来提高前端开发效率、代码质量和可维护性的系统方法。在我的理解和实践中，前端工程化包括以下几个关键方面：1）模块化开发：使用ES Modules、CommonJS等模块系统组织代码；结合Webpack、Rollup等工具实现模块打包和依赖管理。2）规范化流程：实施Git Flow工作流；使用Conventional Commits规范化提交信息；建立强制的代码审查流程。3）自动化构建：配置现代化构建工具链如Webpack、Vite等；实现开发、测试、预发布、生产等多环境构建配置；优化构建性能和产物体积。4）自动化测试：构建完整的测试体系，包括单元测试、集成测试和E2E测试；集成测试覆盖率报告和质量门禁。5）CI/CD流水线：使用GitHub Actions、Jenkins等工具实现持续集成；配置自动部署流程，包括静态分析、测试、构建和发布。6）开发体验优化：配置HMR提升开发效率；集成ESLint、Prettier等工具保障代码质量；引入TypeScript提供类型安全。7）性能监控与优化：集成Lighthouse CI自动评估性能指标；使用Bundle Analyzer分析并优化包体积；实现运行时性能和错误监控。在我负责的电商平台重构项目中，通过系统性地应用这些工程化实践，我们将构建时间缩短了70%，首屏加载时间减少了50%，开发团队的协作效率显著提升，产品质量也得到了很大改善。"
  },
  {
    text: "你是如何处理跨浏览器兼容性问题的？",
    difficulty: "easy",
    modelAnswer: "处理跨浏览器兼容性问题是前端开发的常见挑战，我通常采用以下方法：1）明确支持的浏览器范围：根据用户数据和产品要求，确定需要支持的浏览器版本，避免过度兼容导致的开发成本增加。2）使用现代工具链：利用Babel转译JavaScript代码，确保新语法在旧浏览器中可用；使用PostCSS和Autoprefixer自动添加CSS前缀；使用Browserslist维护统一的目标浏览器配置。3）渐进增强策略：先实现核心功能确保基本可用，再为现代浏览器添加增强体验；使用@supports检测特性支持情况；为关键CSS属性提供备选方案。4）规范化测试流程：使用BrowserStack或LambdaTest等工具在真实浏览器上进行测试；针对关键路径创建跨浏览器测试用例；实施视觉回归测试发现UI差异。5）使用成熟的polyfill：引入core-js、whatwg-fetch等库填补特性空缺；按需加载polyfill减少不必要的性能开销；使用@babel/preset-env实现精确的polyfill注入。6）避免已知陷阱：利用normalize.css或modern-normalize重置浏览器默认样式；使用Flex或Grid而非老旧的布局技术；了解常见的浏览器特异性问题。在我最近的一个企业级应用项目中，通过这些方法，我们成功支持了包括IE11在内的旧版浏览器，同时为现代浏览器用户提供了更优的体验，兼容性相关的Bug减少了约80%。"
  }
];

export const behavioralQuestions = [
  {
    text: "请描述一个你在工作中遇到的挑战，以及你是如何克服的？",
    difficulty: "easy",
    modelAnswer: "在我担任前端开发团队负责人期间，我们面临一个严峻的挑战：公司决定将原有的单体应用改造为微前端架构，但团队成员对这一架构知之甚少，且项目时间紧张，只有3个月交付。面对这一挑战，我采取了以下策略：首先，我花了一周时间深入研究市面上成熟的微前端解决方案，最终选定qiankun框架作为技术基础。接着，我组织了系列知识分享会，确保团队每位成员理解微前端的核心概念和实施方法。然后，我们采用渐进式迁移策略，先将非核心业务模块拆分为独立应用，边学习边实践。在实施过程中，我建立了详细的文档和最佳实践指南，并定期进行代码审查，确保代码质量。同时，我与DevOps团队密切合作，调整CI/CD流程以适应微前端的部署需求。通过团队的共同努力，我们不仅在期限内完成了迁移，还建立了一个更灵活、可扩展的架构，使得后续功能迭代速度提升了40%。这个经历让我认识到，面对技术挑战，系统性学习、知识共享和渐进式实施是克服困难的有效方法。"
  },
  {
    text: "在团队中，你如何处理与同事的意见分歧？请举个例子。",
    difficulty: "medium",
    modelAnswer: "在一个电商平台重构项目中，我与另一位资深开发者在状态管理方案选择上产生了明显分歧。我倾向于使用Context API配合useReducer，认为它足够满足项目需求且能减少外部依赖；而他坚持使用Redux，强调其生态系统和开发工具的优势。面对这一分歧，我采取了以下步骤处理：首先，我安排了一次非正式咖啡会谈，在轻松环境中了解他的具体考虑点。我发现他之前的项目因状态管理不当导致了严重问题，所以特别看重Redux的可预测性。接下来，我提议通过一个小型原型验证两种方案，各自实现相同功能并评估代码复杂度、性能表现和开发体验。我们设定了客观的评估标准，包括初始化时间、内存占用、代码行数等。测试结果显示，对于我们的业务场景，两种方案各有优势：Context方案更轻量，而Redux在处理复杂状态交互时更有优势。最后，我提出折中方案：核心业务流程使用Redux确保稳定性，而相对独立的功能模块使用Context API，以平衡性能和可维护性。我的同事认可了这个方案，因为它既保障了关键业务流程的可靠性，又避免了过度工程化。这次经历教会我，处理技术分歧不应该是赢输的心态，而是要通过客观数据和相互理解，找到最适合项目的解决方案。"
  },
  {
    text: "请分享一次你推动重要变革或创新的经历。",
    difficulty: "hard",
    modelAnswer: "在我担任技术负责人的一个大型金融应用项目中，我发现团队面临持续交付效率低下的问题：每次发布都需要长达3天的回归测试，频繁出现线上bug，且研发团队和测试团队之间经常相互指责。分析后，我认识到这是一个系统性问题，需要从流程和技术两方面进行变革。我制定了一个名为"质量优先"的变革计划，包含以下关键举措：首先，我与CTO沟通获取支持，明确变革愿景和预期收益。随后，我邀请研发、测试、产品和运维团队的核心成员组成变革工作组，确保各方参与感。在技术层面，我们实施了三大变革：1）建立完整的自动化测试体系，包括单元测试、集成测试和E2E测试，将测试覆盖率从20%提升至75%；2）重构CI/CD流水线，将部署时间从4小时缩短至30分钟，并实现一键回滚功能；3）引入特性开关系统，支持灰度发布和A/B测试，降低发布风险。在流程层面，我们实施了测试左移和DevOps文化，将测试人员嵌入到开发团队中，共同制定测试策略；建立日常代码审查和定期架构评审机制；实施"质量守门人"制度，每个迭代派一名资深工程师专注于代码质量把关。推动这一变革并非一帆风顺：最初团队对增加的测试工作有抵触情绪，认为会影响开发速度。为此，我亲自编写示例代码展示如何高效编写测试，并建立"质量之星"激励机制，表彰编写高质量测试的开发者。变革成果显著：六个月后，我们将发布频率从每月一次提升至每周一次，线上bug数量减少了70%，客户满意度提升了35%。这次经历让我深刻理解到：成功的技术变革不仅需要技术方案，更需要有效的变革管理、跨团队协作和建立正确的激励机制。"
  },
  {
    text: "你如何确定工作优先级，特别是在面对多个紧急任务的情况下？",
    difficulty: "medium",
    modelAnswer: "在一个面向全球市场的产品迭代中，我曾同时面临三个紧急任务：修复影响部分付费用户的重要bug、完成下一迭代的核心功能开发、准备即将到来的安全审计。面对这种情况，我采用了一套系统化的方法确定优先级：首先，我使用重要性-紧急性矩阵对任务进行分类。付费用户bug虽然只影响5%的用户，但对业务收入有直接影响，属于"重要且紧急"；核心功能开发是"重要不紧急"；安全审计准备工作属于"紧急但相对次要"（因为审计可以推迟但准备工作确实时间敏感）。其次，我评估每个任务的业务影响和风险。经计算，修复bug每天可挽回约2000美元收入；延迟功能开发会导致产品发布推迟一周，但不会立即影响现有用户；安全审计不合规可能导致合规风险。第三，我评估任务之间的依赖关系。我发现核心功能开发实际上可以与bug修复并行，因为它们影响的代码模块不同；而安全审计准备工作需要团队多人参与。基于以上分析，我做出以下决策：1）优先分配20%的资源立即着手bug修复；2）保持70%的团队继续核心功能开发，避免影响产品路线图；3）分配10%的资源启动安全审计准备，同时与合规团队协商获得一周宽限期。最后，我向产品和管理层清晰地传达了这一决策及其理由，获得了支持。通过这种方法，我们在三天内修复了关键bug，按时完成了核心功能开发，同时也顺利通过了安全审计。这一经验让我认识到，有效的优先级管理不仅是时间管理问题，更需要系统性地评估业务影响、风险和资源分配。"
  },
  {
    text: "描述一次你从失败中学到的重要经验。",
    difficulty: "easy",
    modelAnswer: "在我职业生涯的早期，我负责开发一个社交媒体应用的前端重构项目。当时我满怀信心地采用了最新的技术栈和架构模式，包括一些尚处于实验阶段的框架特性。我们花了3个月时间开发，在内部测试中一切看起来都很完美。然而，当我们发布到生产环境后，立即遇到了严重问题：在某些老旧设备上应用完全无法运行，大量用户反馈性能问题，甚至有用户数据丢失的情况。我们不得不紧急回滚到旧版本，这对公司声誉造成了一定影响，我也因此遭受了职业生涯中最严厉的批评。这次失败给了我深刻的教训。首先，我认识到技术决策不应仅基于技术前沿性，而应该平衡创新与稳定性，特别是对于已有大量用户的产品。其次，我学会了更全面的测试策略的重要性：我们只在高性能设备上进行了测试，完全忽略了用户设备的多样性。第三，我明白了渐进式发布和灰度测试的价值，而不是一次性全量发布。最重要的是，这次经历教会了我面对失败的正确态度。我主动承担责任，没有推脱或找借口，而是带领团队进行了彻底的事后分析，制定了详细的改进计划。在随后的六个月中，我们重新设计了架构，建立了更严格的测试流程，包括在多种设备上进行性能测试，实施了灰度发布机制，并建立了实时监控系统快速发现问题。当我们最终再次发布重构版本时，它比以往任何版本都更稳定、更快速。这次失败经历虽然痛苦，但让我成长为一个更成熟、更谨慎的工程师，也深刻理解了在软件开发中，技术卓越必须与用户需求和业务价值相平衡。"
  }
];
